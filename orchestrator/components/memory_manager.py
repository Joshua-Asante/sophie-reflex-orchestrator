"""
Memory Manager Component

Handles memory operations and data storage.
"""

import json
from typing import Dict, Any, List
from datetime import datetime
import structlog

from memory.vector_store import VectorStore, VectorBackend, MemoryEntry
from ..models.orchestrator_config import OrchestratorConfig

logger = structlog.get_logger()


class MemoryManager:
    """Handles memory operations and data storage."""
    
    def __init__(self, config: OrchestratorConfig):
        self.config = config
        self.vector_store = None
        self.system_config = self._load_system_config()
    
    def _load_system_config(self) -> Dict[str, Any]:
        """Load system configuration."""
        try:
            import yaml
            with open("configs/system.yaml", 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error("Failed to load system configuration", error=str(e))
            return {}
    
    async def initialize(self):
        """Initialize memory components."""
        try:
            # For now, skip vector store initialization to avoid dependency issues
            # self.vector_store = VectorStore(
            #     backend=VectorBackend(self.system_config.get("memory", {}).get("backend", "chromadb")),
            #     config=self.system_config.get("memory", {})
            # )
            logger.info("Memory manager initialized (vector store disabled for testing)")
        except Exception as e:
            logger.error("Failed to initialize memory manager", error=str(e))
            # Don't raise, just log the error for now
    
    async def store_generation_data(self, prover_results: List[Dict[str, Any]], 
                                  evaluation_results: List[Dict[str, Any]], 
                                  generation: int):
        """Store generation data in memory."""
        try:
            # Store prover results
            for prover_result in prover_results:
                memory_entry = MemoryEntry(
                    id=f"prover_{prover_result['agent_id']}_{generation}",
                    content=prover_result["result"].get("best_variant", {}).get("content", ""),
                    embedding=[],  # Will be generated by vector store
                    metadata={
                        "agent_id": prover_result["agent_id"],
                        "generation": generation,
                        "confidence_score": prover_result["confidence_score"],
                        "execution_time": prover_result["execution_time"],
                        "task": prover_result.get("task", ""),
                        "score": prover_result["confidence_score"],
                        "tags": ["prover", f"generation_{generation}"]
                    },
                    timestamp=datetime.now(),
                    agent_id=prover_result["agent_id"],
                    task_id=prover_result.get("task", "")
                )
                
                if self.vector_store:
                    await self.vector_store.add_entry(memory_entry)
                else:
                    logger.warning("Vector store not initialized, skipping memory storage")
            
            # Store evaluation results
            for evaluation in evaluation_results:
                prover_result = evaluation.get("prover_result", {})
                memory_entry = MemoryEntry(
                    id=f"eval_{prover_result['agent_id']}_{generation}",
                    content=json.dumps(evaluation),
                    embedding=[],
                    metadata={
                        "agent_id": prover_result["agent_id"],
                        "generation": generation,
                        "overall_score": evaluation.get("overall_score", 0.0),
                        "evaluator_count": evaluation.get("evaluation_count", 0),
                        "task": prover_result.get("task", ""),
                        "score": evaluation.get("overall_score", 0.0),
                        "tags": ["evaluation", f"generation_{generation}"]
                    },
                    timestamp=datetime.now(),
                    agent_id=prover_result["agent_id"],
                    task_id=prover_result.get("task", "")
                )
                
                if self.vector_store:
                    await self.vector_store.add_entry(memory_entry)
                else:
                    logger.warning("Vector store not initialized, skipping memory storage")
            
            logger.info("Generation data stored", prover_results=len(prover_results), 
                       evaluation_results=len(evaluation_results))
            
        except Exception as e:
            logger.error("Failed to store generation data", error=str(e))
    
    async def retrieve_memory(self, query: str, limit: int = 10) -> List[MemoryEntry]:
        """Retrieve relevant memory entries."""
        try:
            if not self.vector_store:
                return []
            
            entries = await self.vector_store.search(query, limit=limit)
            logger.info("Memory retrieved", query=query, results=len(entries))
            return entries
            
        except Exception as e:
            logger.error("Failed to retrieve memory", error=str(e))
            return []
    
    async def get_agent_memory(self, agent_id: str, limit: int = 10) -> List[MemoryEntry]:
        """Get memory entries for a specific agent."""
        try:
            if not self.vector_store:
                return []
            
            entries = await self.vector_store.search_by_agent(agent_id, limit=limit)
            logger.info("Agent memory retrieved", agent_id=agent_id, results=len(entries))
            return entries
            
        except Exception as e:
            logger.error("Failed to get agent memory", agent_id=agent_id, error=str(e))
            return []
    
    async def get_generation_memory(self, generation: int, limit: int = 10) -> List[MemoryEntry]:
        """Get memory entries for a specific generation."""
        try:
            if not self.vector_store:
                return []
            
            entries = await self.vector_store.search_by_tag(f"generation_{generation}", limit=limit)
            logger.info("Generation memory retrieved", generation=generation, results=len(entries))
            return entries
            
        except Exception as e:
            logger.error("Failed to get generation memory", generation=generation, error=str(e))
            return []
    
    async def clear_memory(self, before_date: datetime = None):
        """Clear memory entries, optionally before a specific date."""
        try:
            if not self.vector_store:
                return
            
            if before_date:
                await self.vector_store.clear_before_date(before_date)
                logger.info("Memory cleared before date", before_date=before_date)
            else:
                await self.vector_store.clear_all()
                logger.info("All memory cleared")
                
        except Exception as e:
            logger.error("Failed to clear memory", error=str(e))
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get memory statistics."""
        try:
            if not self.vector_store:
                return {"error": "Memory store not initialized"}
            
            stats = self.vector_store.get_stats()
            logger.info("Memory statistics retrieved")
            return stats
            
        except Exception as e:
            logger.error("Failed to get memory statistics", error=str(e))
            return {"error": str(e)}
    
    async def store_memory(self, content: str, metadata: Dict[str, Any] = None, 
                          agent_id: str = None, score: float = 0.0, 
                          tags: List[str] = None) -> str:
        """Store memory entry."""
        try:
            # For testing purposes, just return a mock memory ID
            memory_id = f"memory_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
            logger.info("Memory entry stored (mock)", entry_id=memory_id)
            return memory_id
            
        except Exception as e:
            logger.error("Failed to store memory entry", error=str(e))
            return f"memory_error_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}" 